exports[`<FeedItem /> should render with default props 1`] = `
<undefined>
  <function Heading() {
      (0, _classCallCheck3.default)(this, Heading);
      return (0, _possibleConstructorReturn3.default)(this, (Heading.__proto__ || (0, _getPrototypeOf2.default)(Heading)).apply(this, arguments));
    }
    tag="h3">
    Hello World
  </function Heading() {
      (0, _classCallCheck3.default)(this, Heading);
      return (0, _possibleConstructorReturn3.default)(this, (Heading.__proto__ || (0, _getPrototypeOf2.default)(Heading)).apply(this, arguments));
    }>
  <function Paragraph() {
      (0, _classCallCheck3.default)(this, Paragraph);
      return (0, _possibleConstructorReturn3.default)(this, (Paragraph.__proto__ || (0, _getPrototypeOf2.default)(Paragraph)).apply(this, arguments));
    }>
    A project
  </function Paragraph() {
      (0, _classCallCheck3.default)(this, Paragraph);
      return (0, _possibleConstructorReturn3.default)(this, (Paragraph.__proto__ || (0, _getPrototypeOf2.default)(Paragraph)).apply(this, arguments));
    }>
  <function Footer(props, context) {
      (0, _classCallCheck3.default)(this, Footer);
  
      var _this = (0, _possibleConstructorReturn3.default)(this, (Footer.__proto__ || (0, _getPrototypeOf2.default)(Footer)).call(this, props, context));
  
      _this._alignMirror = _this._alignMirror.bind(_this);
      _this._onResize = _this._onResize.bind(_this);
      return _this;
    }
    direction="row"
    responsive={false}>
    <span
      className={undefined}>
      <function (props, context, updater) {
            // This constructor gets overridden by mocks. The argument is used
            // by mocks to assert on what gets mounted.
      
            if (process.env.NODE_ENV !== 'production') {
              process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
            }
      
            // Wire up auto-binding
            if (this.__reactAutoBindPairs.length) {
              bindAutoBindMethods(this);
            }
      
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
      
            this.state = null;
      
            // ReactClasses doesn't have constructors. Instead, they use the
            // getInitialState and componentWillMount methods for initialization.
      
            var initialState = this.getInitialState ? this.getInitialState() : null;
            if (process.env.NODE_ENV !== 'production') {
              // We allow auto-mocks to proceed as if they're returning null.
              if (initialState === undefined && this.getInitialState._isMockFunction) {
                // This is probably bad practice. Consider warning here and
                // deprecating this convenience.
                initialState = null;
              }
            }
            !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;
      
            this.state = initialState;
          }
        onlyActiveOnIndex={false}
        style={Object {}}
        to="/projects/hello-world">
        <function Icon() {
            (0, _classCallCheck3.default)(this, Icon);
            return (0, _possibleConstructorReturn3.default)(this, (Icon.__proto__ || (0, _getPrototypeOf2.default)(Icon)).apply(this, arguments));
          }
          a11yTitleId="chat-title"
          responsive={true}
          size="small" />
        1
      </function (props, context, updater) {
            // This constructor gets overridden by mocks. The argument is used
            // by mocks to assert on what gets mounted.
      
            if (process.env.NODE_ENV !== 'production') {
              process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
            }
      
            // Wire up auto-binding
            if (this.__reactAutoBindPairs.length) {
              bindAutoBindMethods(this);
            }
      
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
      
            this.state = null;
      
            // ReactClasses doesn't have constructors. Instead, they use the
            // getInitialState and componentWillMount methods for initialization.
      
            var initialState = this.getInitialState ? this.getInitialState() : null;
            if (process.env.NODE_ENV !== 'production') {
              // We allow auto-mocks to proceed as if they're returning null.
              if (initialState === undefined && this.getInitialState._isMockFunction) {
                // This is probably bad practice. Consider warning here and
                // deprecating this convenience.
                initialState = null;
              }
            }
            !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;
      
            this.state = initialState;
          }>
    </span>
    <undefined
      user={
        Object {
          "name": "Ryan Collins"
        }
      } />
  </function Footer(props, context) {
      (0, _classCallCheck3.default)(this, Footer);
  
      var _this = (0, _possibleConstructorReturn3.default)(this, (Footer.__proto__ || (0, _getPrototypeOf2.default)(Footer)).call(this, props, context));
  
      _this._alignMirror = _this._alignMirror.bind(_this);
      _this._onResize = _this._onResize.bind(_this);
      return _this;
    }>
</undefined>
`;
